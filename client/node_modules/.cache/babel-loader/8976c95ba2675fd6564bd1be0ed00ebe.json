{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport _ from './utils';\nexport default (function (Base) {\n  return function (_Base) {\n    _inherits(_class, _Base);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n    }\n\n    _createClass(_class, [{\n      key: 'getResolvedState',\n      value: function getResolvedState(props, state) {\n        var resolvedState = _extends({}, _.compactObject(this.state), _.compactObject(this.props), _.compactObject(state), _.compactObject(props));\n\n        return resolvedState;\n      }\n    }, {\n      key: 'getDataModel',\n      value: function getDataModel(newState, dataChanged) {\n        var _this2 = this;\n\n        var columns = newState.columns,\n            _newState$pivotBy = newState.pivotBy,\n            pivotBy = _newState$pivotBy === undefined ? [] : _newState$pivotBy,\n            data = newState.data,\n            resolveData = newState.resolveData,\n            pivotIDKey = newState.pivotIDKey,\n            pivotValKey = newState.pivotValKey,\n            subRowsKey = newState.subRowsKey,\n            aggregatedKey = newState.aggregatedKey,\n            nestingLevelKey = newState.nestingLevelKey,\n            originalKey = newState.originalKey,\n            indexKey = newState.indexKey,\n            groupedByPivotKey = newState.groupedByPivotKey,\n            SubComponent = newState.SubComponent; // Determine Header Groups\n\n        var hasHeaderGroups = false;\n        columns.forEach(function (column) {\n          if (column.columns) {\n            hasHeaderGroups = true;\n          }\n        });\n        var columnsWithExpander = [].concat(_toConsumableArray(columns));\n        var expanderColumn = columns.find(function (col) {\n          return col.expander || col.columns && col.columns.some(function (col2) {\n            return col2.expander;\n          });\n        }); // The actual expander might be in the columns field of a group column\n\n        if (expanderColumn && !expanderColumn.expander) {\n          expanderColumn = expanderColumn.columns.find(function (col) {\n            return col.expander;\n          });\n        } // If we have SubComponent's we need to make sure we have an expander column\n\n\n        if (SubComponent && !expanderColumn) {\n          expanderColumn = {\n            expander: true\n          };\n          columnsWithExpander = [expanderColumn].concat(_toConsumableArray(columnsWithExpander));\n        }\n\n        var makeDecoratedColumn = function makeDecoratedColumn(column, parentColumn) {\n          var dcol = void 0;\n\n          if (column.expander) {\n            dcol = _extends({}, _this2.props.column, _this2.props.expanderDefaults, column);\n          } else {\n            dcol = _extends({}, _this2.props.column, column);\n          } // Ensure minWidth is not greater than maxWidth if set\n\n\n          if (dcol.maxWidth < dcol.minWidth) {\n            dcol.minWidth = dcol.maxWidth;\n          }\n\n          if (parentColumn) {\n            dcol.parentColumn = parentColumn;\n          } // First check for string accessor\n\n\n          if (typeof dcol.accessor === 'string') {\n            dcol.id = dcol.id || dcol.accessor;\n            var accessorString = dcol.accessor;\n\n            dcol.accessor = function (row) {\n              return _.get(row, accessorString);\n            };\n\n            return dcol;\n          } // Fall back to functional accessor (but require an ID)\n\n\n          if (dcol.accessor && !dcol.id) {\n            console.warn(dcol);\n            throw new Error('A column id is required if using a non-string accessor for column above.');\n          } // Fall back to an undefined accessor\n\n\n          if (!dcol.accessor) {\n            dcol.accessor = function () {\n              return undefined;\n            };\n          }\n\n          return dcol;\n        };\n\n        var allDecoratedColumns = []; // Decorate the columns\n\n        var decorateAndAddToAll = function decorateAndAddToAll(column, parentColumn) {\n          var decoratedColumn = makeDecoratedColumn(column, parentColumn);\n          allDecoratedColumns.push(decoratedColumn);\n          return decoratedColumn;\n        };\n\n        var decoratedColumns = columnsWithExpander.map(function (column) {\n          if (column.columns) {\n            return _extends({}, column, {\n              columns: column.columns.map(function (d) {\n                return decorateAndAddToAll(d, column);\n              })\n            });\n          }\n\n          return decorateAndAddToAll(column);\n        }); // Build the visible columns, headers and flat column list\n\n        var visibleColumns = decoratedColumns.slice();\n        var allVisibleColumns = [];\n        visibleColumns = visibleColumns.map(function (column) {\n          if (column.columns) {\n            var visibleSubColumns = column.columns.filter(function (d) {\n              return pivotBy.indexOf(d.id) > -1 ? false : _.getFirstDefined(d.show, true);\n            });\n            return _extends({}, column, {\n              columns: visibleSubColumns\n            });\n          }\n\n          return column;\n        });\n        visibleColumns = visibleColumns.filter(function (column) {\n          return column.columns ? column.columns.length : pivotBy.indexOf(column.id) > -1 ? false : _.getFirstDefined(column.show, true);\n        }); // Find any custom pivot location\n\n        var pivotIndex = visibleColumns.findIndex(function (col) {\n          return col.pivot;\n        }); // Handle Pivot Columns\n\n        if (pivotBy.length) {\n          // Retrieve the pivot columns in the correct pivot order\n          var pivotColumns = [];\n          pivotBy.forEach(function (pivotID) {\n            var found = allDecoratedColumns.find(function (d) {\n              return d.id === pivotID;\n            });\n\n            if (found) {\n              pivotColumns.push(found);\n            }\n          });\n          var PivotParentColumn = pivotColumns.reduce(function (prev, current) {\n            return prev && prev === current.parentColumn && current.parentColumn;\n          }, pivotColumns[0].parentColumn);\n          var PivotGroupHeader = hasHeaderGroups && PivotParentColumn.Header;\n\n          PivotGroupHeader = PivotGroupHeader || function () {\n            return React.createElement('strong', null, 'Pivoted');\n          };\n\n          var pivotColumnGroup = {\n            Header: PivotGroupHeader,\n            columns: pivotColumns.map(function (col) {\n              return _extends({}, _this2.props.pivotDefaults, col, {\n                pivoted: true\n              });\n            }) // Place the pivotColumns back into the visibleColumns\n\n          };\n\n          if (pivotIndex >= 0) {\n            pivotColumnGroup = _extends({}, visibleColumns[pivotIndex], pivotColumnGroup);\n            visibleColumns.splice(pivotIndex, 1, pivotColumnGroup);\n          } else {\n            visibleColumns.unshift(pivotColumnGroup);\n          }\n        } // Build Header Groups\n\n\n        var headerGroups = [];\n        var currentSpan = []; // A convenience function to add a header and reset the currentSpan\n\n        var addHeader = function addHeader(columns, column) {\n          headerGroups.push(_extends({}, _this2.props.column, column, {\n            columns: columns\n          }));\n          currentSpan = [];\n        }; // Build flast list of allVisibleColumns and HeaderGroups\n\n\n        visibleColumns.forEach(function (column) {\n          if (column.columns) {\n            allVisibleColumns = allVisibleColumns.concat(column.columns);\n\n            if (currentSpan.length > 0) {\n              addHeader(currentSpan);\n            }\n\n            addHeader(column.columns, column);\n            return;\n          }\n\n          allVisibleColumns.push(column);\n          currentSpan.push(column);\n        });\n\n        if (hasHeaderGroups && currentSpan.length > 0) {\n          addHeader(currentSpan);\n        } // Access the data\n\n\n        var accessRow = function accessRow(d, i) {\n          var _row;\n\n          var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n          var row = (_row = {}, _defineProperty(_row, originalKey, d), _defineProperty(_row, indexKey, i), _defineProperty(_row, subRowsKey, d[subRowsKey]), _defineProperty(_row, nestingLevelKey, level), _row);\n          allDecoratedColumns.forEach(function (column) {\n            if (column.expander) return;\n            row[column.id] = column.accessor(d);\n          });\n\n          if (row[subRowsKey]) {\n            row[subRowsKey] = row[subRowsKey].map(function (d, i) {\n              return accessRow(d, i, level + 1);\n            });\n          }\n\n          return row;\n        }; // // If the data hasn't changed, just use the cached data\n\n\n        var resolvedData = this.resolvedData; // If the data has changed, run the data resolver and cache the result\n\n        if (!this.resolvedData || dataChanged) {\n          resolvedData = resolveData(data);\n          this.resolvedData = resolvedData;\n        } // Use the resolved data\n\n\n        resolvedData = resolvedData.map(function (d, i) {\n          return accessRow(d, i);\n        }); // TODO: Make it possible to fabricate nested rows without pivoting\n\n        var aggregatingColumns = allVisibleColumns.filter(function (d) {\n          return !d.expander && d.aggregate;\n        }); // If pivoting, recursively group the data\n\n        var aggregate = function aggregate(rows) {\n          var aggregationValues = {};\n          aggregatingColumns.forEach(function (column) {\n            var values = rows.map(function (d) {\n              return d[column.id];\n            });\n            aggregationValues[column.id] = column.aggregate(values, rows);\n          });\n          return aggregationValues;\n        };\n\n        if (pivotBy.length) {\n          var groupRecursively = function groupRecursively(rows, keys) {\n            var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // This is the last level, just return the rows\n\n            if (i === keys.length) {\n              return rows;\n            } // Group the rows together for this level\n\n\n            var groupedRows = Object.entries(_.groupBy(rows, keys[i])).map(function (_ref) {\n              var _ref3;\n\n              var _ref2 = _slicedToArray(_ref, 2),\n                  key = _ref2[0],\n                  value = _ref2[1];\n\n              return _ref3 = {}, _defineProperty(_ref3, pivotIDKey, keys[i]), _defineProperty(_ref3, pivotValKey, key), _defineProperty(_ref3, keys[i], key), _defineProperty(_ref3, subRowsKey, value), _defineProperty(_ref3, nestingLevelKey, i), _defineProperty(_ref3, groupedByPivotKey, true), _ref3;\n            }); // Recurse into the subRows\n\n            groupedRows = groupedRows.map(function (rowGroup) {\n              var _extends2;\n\n              var subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1);\n              return _extends({}, rowGroup, (_extends2 = {}, _defineProperty(_extends2, subRowsKey, subRows), _defineProperty(_extends2, aggregatedKey, true), _extends2), aggregate(subRows));\n            });\n            return groupedRows;\n          };\n\n          resolvedData = groupRecursively(resolvedData, pivotBy);\n        }\n\n        return _extends({}, newState, {\n          resolvedData: resolvedData,\n          allVisibleColumns: allVisibleColumns,\n          headerGroups: headerGroups,\n          allDecoratedColumns: allDecoratedColumns,\n          hasHeaderGroups: hasHeaderGroups\n        });\n      }\n    }, {\n      key: 'getSortedData',\n      value: function getSortedData(resolvedState) {\n        var manual = resolvedState.manual,\n            sorted = resolvedState.sorted,\n            filtered = resolvedState.filtered,\n            defaultFilterMethod = resolvedState.defaultFilterMethod,\n            resolvedData = resolvedState.resolvedData,\n            allDecoratedColumns = resolvedState.allDecoratedColumns;\n        var sortMethodsByColumnID = {};\n        allDecoratedColumns.filter(function (col) {\n          return col.sortMethod;\n        }).forEach(function (col) {\n          sortMethodsByColumnID[col.id] = col.sortMethod;\n        }); // Resolve the data from either manual data or sorted data\n\n        return {\n          sortedData: manual ? resolvedData : this.sortData(this.filterData(resolvedData, filtered, defaultFilterMethod, allDecoratedColumns), sorted, sortMethodsByColumnID)\n        };\n      }\n    }, {\n      key: 'fireFetchData',\n      value: function fireFetchData() {\n        // determine the current state, preferring certain state values over props\n        var currentState = _extends({}, this.getResolvedState(), {\n          page: this.getStateOrProp('page'),\n          pageSize: this.getStateOrProp('pageSize'),\n          filtered: this.getStateOrProp('filtered')\n        });\n\n        this.props.onFetchData(currentState, this);\n      }\n    }, {\n      key: 'getPropOrState',\n      value: function getPropOrState(key) {\n        return _.getFirstDefined(this.props[key], this.state[key]);\n      }\n    }, {\n      key: 'getStateOrProp',\n      value: function getStateOrProp(key) {\n        return _.getFirstDefined(this.state[key], this.props[key]);\n      }\n    }, {\n      key: 'filterData',\n      value: function filterData(data, filtered, defaultFilterMethod, allVisibleColumns) {\n        var _this3 = this;\n\n        var filteredData = data;\n\n        if (filtered.length) {\n          filteredData = filtered.reduce(function (filteredSoFar, nextFilter) {\n            var column = allVisibleColumns.find(function (x) {\n              return x.id === nextFilter.id;\n            }); // Don't filter hidden columns or columns that have had their filters disabled\n\n            if (!column || column.filterable === false) {\n              return filteredSoFar;\n            }\n\n            var filterMethod = column.filterMethod || defaultFilterMethod; // If 'filterAll' is set to true, pass the entire dataset to the filter method\n\n            if (column.filterAll) {\n              return filterMethod(nextFilter, filteredSoFar, column);\n            }\n\n            return filteredSoFar.filter(function (row) {\n              return filterMethod(nextFilter, row, column);\n            });\n          }, filteredData); // Apply the filter to the subrows if we are pivoting, and then\n          // filter any rows without subcolumns because it would be strange to show\n\n          filteredData = filteredData.map(function (row) {\n            if (!row[_this3.props.subRowsKey]) {\n              return row;\n            }\n\n            return _extends({}, row, _defineProperty({}, _this3.props.subRowsKey, _this3.filterData(row[_this3.props.subRowsKey], filtered, defaultFilterMethod, allVisibleColumns)));\n          }).filter(function (row) {\n            if (!row[_this3.props.subRowsKey]) {\n              return true;\n            }\n\n            return row[_this3.props.subRowsKey].length > 0;\n          });\n        }\n\n        return filteredData;\n      }\n    }, {\n      key: 'sortData',\n      value: function sortData(data, sorted) {\n        var _this4 = this;\n\n        var sortMethodsByColumnID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (!sorted.length) {\n          return data;\n        }\n\n        var sortedData = (this.props.orderByMethod || _.orderBy)(data, sorted.map(function (sort) {\n          // Support custom sorting methods for each column\n          if (sortMethodsByColumnID[sort.id]) {\n            return function (a, b) {\n              return sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc);\n            };\n          }\n\n          return function (a, b) {\n            return _this4.props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc);\n          };\n        }), sorted.map(function (d) {\n          return !d.desc;\n        }), this.props.indexKey);\n\n        sortedData.forEach(function (row) {\n          if (!row[_this4.props.subRowsKey]) {\n            return;\n          }\n\n          row[_this4.props.subRowsKey] = _this4.sortData(row[_this4.props.subRowsKey], sorted, sortMethodsByColumnID);\n        });\n        return sortedData;\n      }\n    }, {\n      key: 'getMinRows',\n      value: function getMinRows() {\n        return _.getFirstDefined(this.props.minRows, this.getStateOrProp('pageSize'));\n      } // User actions\n\n    }, {\n      key: 'onPageChange',\n      value: function onPageChange(page) {\n        var _props = this.props,\n            onPageChange = _props.onPageChange,\n            collapseOnPageChange = _props.collapseOnPageChange;\n        var newState = {\n          page: page\n        };\n\n        if (collapseOnPageChange) {\n          newState.expanded = {};\n        }\n\n        this.setStateWithData(newState, function () {\n          return onPageChange && onPageChange(page);\n        });\n      }\n    }, {\n      key: 'onPageSizeChange',\n      value: function onPageSizeChange(newPageSize) {\n        var onPageSizeChange = this.props.onPageSizeChange;\n\n        var _getResolvedState = this.getResolvedState(),\n            pageSize = _getResolvedState.pageSize,\n            page = _getResolvedState.page; // Normalize the page to display\n\n\n        var currentRow = pageSize * page;\n        var newPage = Math.floor(currentRow / newPageSize);\n        this.setStateWithData({\n          pageSize: newPageSize,\n          page: newPage\n        }, function () {\n          return onPageSizeChange && onPageSizeChange(newPageSize, newPage);\n        });\n      }\n    }, {\n      key: 'sortColumn',\n      value: function sortColumn(column, additive) {\n        var _getResolvedState2 = this.getResolvedState(),\n            sorted = _getResolvedState2.sorted,\n            skipNextSort = _getResolvedState2.skipNextSort,\n            defaultSortDesc = _getResolvedState2.defaultSortDesc;\n\n        var firstSortDirection = Object.prototype.hasOwnProperty.call(column, 'defaultSortDesc') ? column.defaultSortDesc : defaultSortDesc;\n        var secondSortDirection = !firstSortDirection; // we can't stop event propagation from the column resize move handlers\n        // attached to the document because of react's synthetic events\n        // so we have to prevent the sort function from actually sorting\n        // if we click on the column resize element within a header.\n\n        if (skipNextSort) {\n          this.setStateWithData({\n            skipNextSort: false\n          });\n          return;\n        }\n\n        var onSortedChange = this.props.onSortedChange;\n\n        var newSorted = _.clone(sorted || []).map(function (d) {\n          d.desc = _.isSortingDesc(d);\n          return d;\n        });\n\n        if (!_.isArray(column)) {\n          // Single-Sort\n          var existingIndex = newSorted.findIndex(function (d) {\n            return d.id === column.id;\n          });\n\n          if (existingIndex > -1) {\n            var existing = newSorted[existingIndex];\n\n            if (existing.desc === secondSortDirection) {\n              if (additive) {\n                newSorted.splice(existingIndex, 1);\n              } else {\n                existing.desc = firstSortDirection;\n                newSorted = [existing];\n              }\n            } else {\n              existing.desc = secondSortDirection;\n\n              if (!additive) {\n                newSorted = [existing];\n              }\n            }\n          } else if (additive) {\n            newSorted.push({\n              id: column.id,\n              desc: firstSortDirection\n            });\n          } else {\n            newSorted = [{\n              id: column.id,\n              desc: firstSortDirection\n            }];\n          }\n        } else {\n          // Multi-Sort\n          var _existingIndex = newSorted.findIndex(function (d) {\n            return d.id === column[0].id;\n          }); // Existing Sorted Column\n\n\n          if (_existingIndex > -1) {\n            var _existing = newSorted[_existingIndex];\n\n            if (_existing.desc === secondSortDirection) {\n              if (additive) {\n                newSorted.splice(_existingIndex, column.length);\n              } else {\n                column.forEach(function (d, i) {\n                  newSorted[_existingIndex + i].desc = firstSortDirection;\n                });\n              }\n            } else {\n              column.forEach(function (d, i) {\n                newSorted[_existingIndex + i].desc = secondSortDirection;\n              });\n            }\n\n            if (!additive) {\n              newSorted = newSorted.slice(_existingIndex, column.length);\n            } // New Sort Column\n\n          } else if (additive) {\n            newSorted = newSorted.concat(column.map(function (d) {\n              return {\n                id: d.id,\n                desc: firstSortDirection\n              };\n            }));\n          } else {\n            newSorted = column.map(function (d) {\n              return {\n                id: d.id,\n                desc: firstSortDirection\n              };\n            });\n          }\n        }\n\n        this.setStateWithData({\n          page: !sorted.length && newSorted.length || !additive ? 0 : this.state.page,\n          sorted: newSorted\n        }, function () {\n          return onSortedChange && onSortedChange(newSorted, column, additive);\n        });\n      }\n    }, {\n      key: 'filterColumn',\n      value: function filterColumn(column, value) {\n        var _getResolvedState3 = this.getResolvedState(),\n            filtered = _getResolvedState3.filtered;\n\n        var onFilteredChange = this.props.onFilteredChange; // Remove old filter first if it exists\n\n        var newFiltering = (filtered || []).filter(function (x) {\n          return x.id !== column.id;\n        });\n\n        if (value !== '') {\n          newFiltering.push({\n            id: column.id,\n            value: value\n          });\n        }\n\n        this.setStateWithData({\n          filtered: newFiltering\n        }, function () {\n          return onFilteredChange && onFilteredChange(newFiltering, column, value);\n        });\n      }\n    }, {\n      key: 'resizeColumnStart',\n      value: function resizeColumnStart(event, column, isTouch) {\n        var _this5 = this;\n\n        event.stopPropagation();\n        var parentWidth = event.target.parentElement.getBoundingClientRect().width;\n        var pageX = void 0;\n\n        if (isTouch) {\n          pageX = event.changedTouches[0].pageX;\n        } else {\n          pageX = event.pageX;\n        }\n\n        this.trapEvents = true;\n        this.setStateWithData({\n          currentlyResizing: {\n            id: column.id,\n            startX: pageX,\n            parentWidth: parentWidth\n          }\n        }, function () {\n          if (isTouch) {\n            document.addEventListener('touchmove', _this5.resizeColumnMoving);\n            document.addEventListener('touchcancel', _this5.resizeColumnEnd);\n            document.addEventListener('touchend', _this5.resizeColumnEnd);\n          } else {\n            document.addEventListener('mousemove', _this5.resizeColumnMoving);\n            document.addEventListener('mouseup', _this5.resizeColumnEnd);\n            document.addEventListener('mouseleave', _this5.resizeColumnEnd);\n          }\n        });\n      }\n    }, {\n      key: 'resizeColumnMoving',\n      value: function resizeColumnMoving(event) {\n        event.stopPropagation();\n        var _props2 = this.props,\n            onResizedChange = _props2.onResizedChange,\n            column = _props2.column;\n\n        var _getResolvedState4 = this.getResolvedState(),\n            resized = _getResolvedState4.resized,\n            currentlyResizing = _getResolvedState4.currentlyResizing,\n            columns = _getResolvedState4.columns;\n\n        var currentColumn = columns.find(function (c) {\n          return c.accessor === currentlyResizing.id || c.id === currentlyResizing.id;\n        });\n        var minResizeWidth = currentColumn && currentColumn.minResizeWidth != null ? currentColumn.minResizeWidth : column.minResizeWidth; // Delete old value\n\n        var newResized = resized.filter(function (x) {\n          return x.id !== currentlyResizing.id;\n        });\n        var pageX = void 0;\n\n        if (event.type === 'touchmove') {\n          pageX = event.changedTouches[0].pageX;\n        } else if (event.type === 'mousemove') {\n          pageX = event.pageX;\n        }\n\n        var newWidth = Math.max(currentlyResizing.parentWidth + pageX - currentlyResizing.startX, minResizeWidth);\n        newResized.push({\n          id: currentlyResizing.id,\n          value: newWidth\n        });\n        this.setStateWithData({\n          resized: newResized\n        }, function () {\n          return onResizedChange && onResizedChange(newResized, event);\n        });\n      }\n    }, {\n      key: 'resizeColumnEnd',\n      value: function resizeColumnEnd(event) {\n        event.stopPropagation();\n        var isTouch = event.type === 'touchend' || event.type === 'touchcancel';\n\n        if (isTouch) {\n          document.removeEventListener('touchmove', this.resizeColumnMoving);\n          document.removeEventListener('touchcancel', this.resizeColumnEnd);\n          document.removeEventListener('touchend', this.resizeColumnEnd);\n        } // If its a touch event clear the mouse one's as well because sometimes\n        // the mouseDown event gets called as well, but the mouseUp event doesn't\n\n\n        document.removeEventListener('mousemove', this.resizeColumnMoving);\n        document.removeEventListener('mouseup', this.resizeColumnEnd);\n        document.removeEventListener('mouseleave', this.resizeColumnEnd); // The touch events don't propagate up to the sorting's onMouseDown event so\n        // no need to prevent it from happening or else the first click after a touch\n        // event resize will not sort the column.\n\n        if (!isTouch) {\n          this.setStateWithData({\n            skipNextSort: true,\n            currentlyResizing: false\n          });\n        }\n      }\n    }]);\n\n    return _class;\n  }(Base);\n});","map":{"version":3,"mappings":"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","names":["React","_","_inherits","_classCallCheck","_createClass","key","value","props","state","resolvedState","compactObject","newState","dataChanged","columns","pivotBy","data","resolveData","pivotIDKey","pivotValKey","subRowsKey","aggregatedKey","nestingLevelKey","originalKey","indexKey","groupedByPivotKey","SubComponent","hasHeaderGroups","forEach","column","columnsWithExpander","expanderColumn","find","col","expander","some","col2","makeDecoratedColumn","parentColumn","dcol","_this2","expanderDefaults","maxWidth","minWidth","accessor","id","accessorString","get","row","console","warn","Error","undefined","allDecoratedColumns","decorateAndAddToAll","decoratedColumn","push","decoratedColumns","map","d","visibleColumns","slice","allVisibleColumns","visibleSubColumns","filter","indexOf","getFirstDefined","show","length","pivotIndex","findIndex","pivot","pivotColumns","found","pivotID","PivotParentColumn","reduce","prev","current","PivotGroupHeader","Header","pivotColumnGroup","pivotDefaults","pivoted","splice","unshift","headerGroups","currentSpan","addHeader","concat","accessRow","i","level","resolvedData","aggregatingColumns","aggregate","aggregationValues","values","rows","groupRecursively","keys","groupedRows","Object","entries","groupBy","subRows","rowGroup","manual","sorted","filtered","defaultFilterMethod","sortMethodsByColumnID","sortMethod","sortedData","sortData","filterData","currentState","getResolvedState","page","getStateOrProp","pageSize","onFetchData","filteredData","filteredSoFar","nextFilter","x","filterable","filterMethod","filterAll","_this3","orderByMethod","orderBy","sort","a","b","desc","_this4","defaultSortMethod","minRows","onPageChange","collapseOnPageChange","expanded","setStateWithData","newPageSize","onPageSizeChange","currentRow","newPage","Math","floor","additive","skipNextSort","defaultSortDesc","firstSortDirection","prototype","hasOwnProperty","call","secondSortDirection","onSortedChange","newSorted","clone","isSortingDesc","isArray","existingIndex","existing","onFilteredChange","newFiltering","event","isTouch","stopPropagation","parentWidth","target","parentElement","getBoundingClientRect","width","pageX","changedTouches","trapEvents","currentlyResizing","startX","document","addEventListener","_this5","resizeColumnMoving","resizeColumnEnd","onResizedChange","resized","currentColumn","c","minResizeWidth","newResized","type","newWidth","max","removeEventListener","Base"],"sources":["/Users/admin/Documents/tasks/mern-app/client/node_modules/react-table/src/methods.js"],"sourcesContent":["import React from 'react'\nimport _ from './utils'\n\nexport default Base =>\n  class extends Base {\n    getResolvedState (props, state) {\n      const resolvedState = {\n        ..._.compactObject(this.state),\n        ..._.compactObject(this.props),\n        ..._.compactObject(state),\n        ..._.compactObject(props),\n      }\n      return resolvedState\n    }\n\n    getDataModel (newState, dataChanged) {\n      const {\n        columns,\n        pivotBy = [],\n        data,\n        resolveData,\n        pivotIDKey,\n        pivotValKey,\n        subRowsKey,\n        aggregatedKey,\n        nestingLevelKey,\n        originalKey,\n        indexKey,\n        groupedByPivotKey,\n        SubComponent,\n      } = newState\n\n      // Determine Header Groups\n      let hasHeaderGroups = false\n      columns.forEach(column => {\n        if (column.columns) {\n          hasHeaderGroups = true\n        }\n      })\n\n      let columnsWithExpander = [...columns]\n\n      let expanderColumn = columns.find(\n        col => col.expander || (col.columns && col.columns.some(col2 => col2.expander))\n      )\n      // The actual expander might be in the columns field of a group column\n      if (expanderColumn && !expanderColumn.expander) {\n        expanderColumn = expanderColumn.columns.find(col => col.expander)\n      }\n\n      // If we have SubComponent's we need to make sure we have an expander column\n      if (SubComponent && !expanderColumn) {\n        expanderColumn = { expander: true }\n        columnsWithExpander = [expanderColumn, ...columnsWithExpander]\n      }\n\n      const makeDecoratedColumn = (column, parentColumn) => {\n        let dcol\n        if (column.expander) {\n          dcol = {\n            ...this.props.column,\n            ...this.props.expanderDefaults,\n            ...column,\n          }\n        } else {\n          dcol = {\n            ...this.props.column,\n            ...column,\n          }\n        }\n\n        // Ensure minWidth is not greater than maxWidth if set\n        if (dcol.maxWidth < dcol.minWidth) {\n          dcol.minWidth = dcol.maxWidth\n        }\n\n        if (parentColumn) {\n          dcol.parentColumn = parentColumn\n        }\n\n        // First check for string accessor\n        if (typeof dcol.accessor === 'string') {\n          dcol.id = dcol.id || dcol.accessor\n          const accessorString = dcol.accessor\n          dcol.accessor = row => _.get(row, accessorString)\n          return dcol\n        }\n\n        // Fall back to functional accessor (but require an ID)\n        if (dcol.accessor && !dcol.id) {\n          console.warn(dcol)\n          throw new Error(\n            'A column id is required if using a non-string accessor for column above.'\n          )\n        }\n\n        // Fall back to an undefined accessor\n        if (!dcol.accessor) {\n          dcol.accessor = () => undefined\n        }\n\n        return dcol\n      }\n\n      const allDecoratedColumns = []\n\n      // Decorate the columns\n      const decorateAndAddToAll = (column, parentColumn) => {\n        const decoratedColumn = makeDecoratedColumn(column, parentColumn)\n        allDecoratedColumns.push(decoratedColumn)\n        return decoratedColumn\n      }\n\n      const decoratedColumns = columnsWithExpander.map(column => {\n        if (column.columns) {\n          return {\n            ...column,\n            columns: column.columns.map(d => decorateAndAddToAll(d, column)),\n          }\n        }\n        return decorateAndAddToAll(column)\n      })\n\n      // Build the visible columns, headers and flat column list\n      let visibleColumns = decoratedColumns.slice()\n      let allVisibleColumns = []\n\n      visibleColumns = visibleColumns.map(column => {\n        if (column.columns) {\n          const visibleSubColumns = column.columns.filter(d =>\n            pivotBy.indexOf(d.id) > -1 ? false : _.getFirstDefined(d.show, true)\n          )\n          return {\n            ...column,\n            columns: visibleSubColumns,\n          }\n        }\n        return column\n      })\n\n      visibleColumns = visibleColumns.filter(column =>\n        column.columns\n          ? column.columns.length\n          : pivotBy.indexOf(column.id) > -1\n            ? false\n            : _.getFirstDefined(column.show, true)\n      )\n\n      // Find any custom pivot location\n      const pivotIndex = visibleColumns.findIndex(col => col.pivot)\n\n      // Handle Pivot Columns\n      if (pivotBy.length) {\n        // Retrieve the pivot columns in the correct pivot order\n        const pivotColumns = []\n        pivotBy.forEach(pivotID => {\n          const found = allDecoratedColumns.find(d => d.id === pivotID)\n          if (found) {\n            pivotColumns.push(found)\n          }\n        })\n\n        const PivotParentColumn = pivotColumns.reduce(\n          (prev, current) => prev && prev === current.parentColumn && current.parentColumn,\n          pivotColumns[0].parentColumn\n        )\n\n        let PivotGroupHeader = hasHeaderGroups && PivotParentColumn.Header\n        PivotGroupHeader = PivotGroupHeader || (() => <strong>Pivoted</strong>)\n\n        let pivotColumnGroup = {\n          Header: PivotGroupHeader,\n          columns: pivotColumns.map(col => ({\n            ...this.props.pivotDefaults,\n            ...col,\n            pivoted: true,\n          })),\n        }\n\n        // Place the pivotColumns back into the visibleColumns\n        if (pivotIndex >= 0) {\n          pivotColumnGroup = {\n            ...visibleColumns[pivotIndex],\n            ...pivotColumnGroup,\n          }\n          visibleColumns.splice(pivotIndex, 1, pivotColumnGroup)\n        } else {\n          visibleColumns.unshift(pivotColumnGroup)\n        }\n      }\n\n      // Build Header Groups\n      const headerGroups = []\n      let currentSpan = []\n\n      // A convenience function to add a header and reset the currentSpan\n      const addHeader = (columns, column) => {\n        headerGroups.push({\n          ...this.props.column,\n          ...column,\n          columns,\n        })\n        currentSpan = []\n      }\n\n      // Build flast list of allVisibleColumns and HeaderGroups\n      visibleColumns.forEach(column => {\n        if (column.columns) {\n          allVisibleColumns = allVisibleColumns.concat(column.columns)\n          if (currentSpan.length > 0) {\n            addHeader(currentSpan)\n          }\n          addHeader(column.columns, column)\n          return\n        }\n        allVisibleColumns.push(column)\n        currentSpan.push(column)\n      })\n      if (hasHeaderGroups && currentSpan.length > 0) {\n        addHeader(currentSpan)\n      }\n\n      // Access the data\n      const accessRow = (d, i, level = 0) => {\n        const row = {\n          [originalKey]: d,\n          [indexKey]: i,\n          [subRowsKey]: d[subRowsKey],\n          [nestingLevelKey]: level,\n        }\n        allDecoratedColumns.forEach(column => {\n          if (column.expander) return\n          row[column.id] = column.accessor(d)\n        })\n        if (row[subRowsKey]) {\n          row[subRowsKey] = row[subRowsKey].map((d, i) => accessRow(d, i, level + 1))\n        }\n        return row\n      }\n\n      // // If the data hasn't changed, just use the cached data\n      let resolvedData = this.resolvedData\n      // If the data has changed, run the data resolver and cache the result\n      if (!this.resolvedData || dataChanged) {\n        resolvedData = resolveData(data)\n        this.resolvedData = resolvedData\n      }\n      // Use the resolved data\n      resolvedData = resolvedData.map((d, i) => accessRow(d, i))\n\n      // TODO: Make it possible to fabricate nested rows without pivoting\n      const aggregatingColumns = allVisibleColumns.filter(d => !d.expander && d.aggregate)\n\n      // If pivoting, recursively group the data\n      const aggregate = rows => {\n        const aggregationValues = {}\n        aggregatingColumns.forEach(column => {\n          const values = rows.map(d => d[column.id])\n          aggregationValues[column.id] = column.aggregate(values, rows)\n        })\n        return aggregationValues\n      }\n      if (pivotBy.length) {\n        const groupRecursively = (rows, keys, i = 0) => {\n          // This is the last level, just return the rows\n          if (i === keys.length) {\n            return rows\n          }\n          // Group the rows together for this level\n          let groupedRows = Object.entries(_.groupBy(rows, keys[i])).map(([key, value]) => ({\n            [pivotIDKey]: keys[i],\n            [pivotValKey]: key,\n            [keys[i]]: key,\n            [subRowsKey]: value,\n            [nestingLevelKey]: i,\n            [groupedByPivotKey]: true,\n          }))\n          // Recurse into the subRows\n          groupedRows = groupedRows.map(rowGroup => {\n            const subRows = groupRecursively(rowGroup[subRowsKey], keys, i + 1)\n            return {\n              ...rowGroup,\n              [subRowsKey]: subRows,\n              [aggregatedKey]: true,\n              ...aggregate(subRows),\n            }\n          })\n          return groupedRows\n        }\n        resolvedData = groupRecursively(resolvedData, pivotBy)\n      }\n\n      return {\n        ...newState,\n        resolvedData,\n        allVisibleColumns,\n        headerGroups,\n        allDecoratedColumns,\n        hasHeaderGroups,\n      }\n    }\n\n    getSortedData (resolvedState) {\n      const {\n        manual,\n        sorted,\n        filtered,\n        defaultFilterMethod,\n        resolvedData,\n        allDecoratedColumns,\n      } = resolvedState\n\n      const sortMethodsByColumnID = {}\n\n      allDecoratedColumns\n        .filter(col => col.sortMethod)\n        .forEach(col => {\n          sortMethodsByColumnID[col.id] = col.sortMethod\n        })\n\n      // Resolve the data from either manual data or sorted data\n      return {\n        sortedData: manual\n          ? resolvedData\n          : this.sortData(\n            this.filterData(resolvedData, filtered, defaultFilterMethod, allDecoratedColumns),\n            sorted,\n            sortMethodsByColumnID\n          ),\n      }\n    }\n\n    fireFetchData () {\n      // determine the current state, preferring certain state values over props\n      const currentState = {\n        ...this.getResolvedState(),\n        page: this.getStateOrProp('page'),\n        pageSize: this.getStateOrProp('pageSize'),\n        filtered: this.getStateOrProp('filtered'),\n      }\n\n      this.props.onFetchData(currentState, this)\n    }\n\n    getPropOrState (key) {\n      return _.getFirstDefined(this.props[key], this.state[key])\n    }\n\n    getStateOrProp (key) {\n      return _.getFirstDefined(this.state[key], this.props[key])\n    }\n\n    filterData (data, filtered, defaultFilterMethod, allVisibleColumns) {\n      let filteredData = data\n\n      if (filtered.length) {\n        filteredData = filtered.reduce((filteredSoFar, nextFilter) => {\n          const column = allVisibleColumns.find(x => x.id === nextFilter.id)\n\n          // Don't filter hidden columns or columns that have had their filters disabled\n          if (!column || column.filterable === false) {\n            return filteredSoFar\n          }\n\n          const filterMethod = column.filterMethod || defaultFilterMethod\n\n          // If 'filterAll' is set to true, pass the entire dataset to the filter method\n          if (column.filterAll) {\n            return filterMethod(nextFilter, filteredSoFar, column)\n          }\n          return filteredSoFar.filter(row => filterMethod(nextFilter, row, column))\n        }, filteredData)\n\n        // Apply the filter to the subrows if we are pivoting, and then\n        // filter any rows without subcolumns because it would be strange to show\n        filteredData = filteredData\n          .map(row => {\n            if (!row[this.props.subRowsKey]) {\n              return row\n            }\n            return {\n              ...row,\n              [this.props.subRowsKey]: this.filterData(\n                row[this.props.subRowsKey],\n                filtered,\n                defaultFilterMethod,\n                allVisibleColumns\n              ),\n            }\n          })\n          .filter(row => {\n            if (!row[this.props.subRowsKey]) {\n              return true\n            }\n            return row[this.props.subRowsKey].length > 0\n          })\n      }\n\n      return filteredData\n    }\n\n    sortData (data, sorted, sortMethodsByColumnID = {}) {\n      if (!sorted.length) {\n        return data\n      }\n\n      const sortedData = (this.props.orderByMethod || _.orderBy)(\n        data,\n        sorted.map(sort => {\n          // Support custom sorting methods for each column\n          if (sortMethodsByColumnID[sort.id]) {\n            return (a, b) => sortMethodsByColumnID[sort.id](a[sort.id], b[sort.id], sort.desc)\n          }\n          return (a, b) => this.props.defaultSortMethod(a[sort.id], b[sort.id], sort.desc)\n        }),\n        sorted.map(d => !d.desc),\n        this.props.indexKey\n      )\n\n      sortedData.forEach(row => {\n        if (!row[this.props.subRowsKey]) {\n          return\n        }\n        row[this.props.subRowsKey] = this.sortData(\n          row[this.props.subRowsKey],\n          sorted,\n          sortMethodsByColumnID\n        )\n      })\n\n      return sortedData\n    }\n\n    getMinRows () {\n      return _.getFirstDefined(this.props.minRows, this.getStateOrProp('pageSize'))\n    }\n\n    // User actions\n    onPageChange (page) {\n      const { onPageChange, collapseOnPageChange } = this.props\n\n      const newState = { page }\n      if (collapseOnPageChange) {\n        newState.expanded = {}\n      }\n      this.setStateWithData(newState, () => onPageChange && onPageChange(page))\n    }\n\n    onPageSizeChange (newPageSize) {\n      const { onPageSizeChange } = this.props\n      const { pageSize, page } = this.getResolvedState()\n\n      // Normalize the page to display\n      const currentRow = pageSize * page\n      const newPage = Math.floor(currentRow / newPageSize)\n\n      this.setStateWithData(\n        {\n          pageSize: newPageSize,\n          page: newPage,\n        },\n        () => onPageSizeChange && onPageSizeChange(newPageSize, newPage)\n      )\n    }\n\n    sortColumn (column, additive) {\n      const { sorted, skipNextSort, defaultSortDesc } = this.getResolvedState()\n\n      const firstSortDirection = Object.prototype.hasOwnProperty.call(column, 'defaultSortDesc')\n        ? column.defaultSortDesc\n        : defaultSortDesc\n      const secondSortDirection = !firstSortDirection\n\n      // we can't stop event propagation from the column resize move handlers\n      // attached to the document because of react's synthetic events\n      // so we have to prevent the sort function from actually sorting\n      // if we click on the column resize element within a header.\n      if (skipNextSort) {\n        this.setStateWithData({\n          skipNextSort: false,\n        })\n        return\n      }\n\n      const { onSortedChange } = this.props\n\n      let newSorted = _.clone(sorted || []).map(d => {\n        d.desc = _.isSortingDesc(d)\n        return d\n      })\n      if (!_.isArray(column)) {\n        // Single-Sort\n        const existingIndex = newSorted.findIndex(d => d.id === column.id)\n        if (existingIndex > -1) {\n          const existing = newSorted[existingIndex]\n          if (existing.desc === secondSortDirection) {\n            if (additive) {\n              newSorted.splice(existingIndex, 1)\n            } else {\n              existing.desc = firstSortDirection\n              newSorted = [existing]\n            }\n          } else {\n            existing.desc = secondSortDirection\n            if (!additive) {\n              newSorted = [existing]\n            }\n          }\n        } else if (additive) {\n          newSorted.push({\n            id: column.id,\n            desc: firstSortDirection,\n          })\n        } else {\n          newSorted = [\n            {\n              id: column.id,\n              desc: firstSortDirection,\n            },\n          ]\n        }\n      } else {\n        // Multi-Sort\n        const existingIndex = newSorted.findIndex(d => d.id === column[0].id)\n        // Existing Sorted Column\n        if (existingIndex > -1) {\n          const existing = newSorted[existingIndex]\n          if (existing.desc === secondSortDirection) {\n            if (additive) {\n              newSorted.splice(existingIndex, column.length)\n            } else {\n              column.forEach((d, i) => {\n                newSorted[existingIndex + i].desc = firstSortDirection\n              })\n            }\n          } else {\n            column.forEach((d, i) => {\n              newSorted[existingIndex + i].desc = secondSortDirection\n            })\n          }\n          if (!additive) {\n            newSorted = newSorted.slice(existingIndex, column.length)\n          }\n          // New Sort Column\n        } else if (additive) {\n          newSorted = newSorted.concat(\n            column.map(d => ({\n              id: d.id,\n              desc: firstSortDirection,\n            }))\n          )\n        } else {\n          newSorted = column.map(d => ({\n            id: d.id,\n            desc: firstSortDirection,\n          }))\n        }\n      }\n\n      this.setStateWithData(\n        {\n          page: (!sorted.length && newSorted.length) || !additive ? 0 : this.state.page,\n          sorted: newSorted,\n        },\n        () => onSortedChange && onSortedChange(newSorted, column, additive)\n      )\n    }\n\n    filterColumn (column, value) {\n      const { filtered } = this.getResolvedState()\n      const { onFilteredChange } = this.props\n\n      // Remove old filter first if it exists\n      const newFiltering = (filtered || []).filter(x => x.id !== column.id)\n\n      if (value !== '') {\n        newFiltering.push({\n          id: column.id,\n          value,\n        })\n      }\n\n      this.setStateWithData(\n        {\n          filtered: newFiltering,\n        },\n        () => onFilteredChange && onFilteredChange(newFiltering, column, value)\n      )\n    }\n\n    resizeColumnStart (event, column, isTouch) {\n      event.stopPropagation()\n      const parentWidth = event.target.parentElement.getBoundingClientRect().width\n\n      let pageX\n      if (isTouch) {\n        pageX = event.changedTouches[0].pageX\n      } else {\n        pageX = event.pageX\n      }\n\n      this.trapEvents = true\n      this.setStateWithData(\n        {\n          currentlyResizing: {\n            id: column.id,\n            startX: pageX,\n            parentWidth,\n          },\n        },\n        () => {\n          if (isTouch) {\n            document.addEventListener('touchmove', this.resizeColumnMoving)\n            document.addEventListener('touchcancel', this.resizeColumnEnd)\n            document.addEventListener('touchend', this.resizeColumnEnd)\n          } else {\n            document.addEventListener('mousemove', this.resizeColumnMoving)\n            document.addEventListener('mouseup', this.resizeColumnEnd)\n            document.addEventListener('mouseleave', this.resizeColumnEnd)\n          }\n        }\n      )\n    }\n\n    resizeColumnMoving (event) {\n      event.stopPropagation()\n      const { onResizedChange, column } = this.props\n      const { resized, currentlyResizing, columns } = this.getResolvedState()\n      const currentColumn = columns.find(\n        c => c.accessor === currentlyResizing.id || c.id === currentlyResizing.id\n      )\n      const minResizeWidth =\n        currentColumn && currentColumn.minResizeWidth != null\n          ? currentColumn.minResizeWidth\n          : column.minResizeWidth\n\n      // Delete old value\n      const newResized = resized.filter(x => x.id !== currentlyResizing.id)\n\n      let pageX\n\n      if (event.type === 'touchmove') {\n        pageX = event.changedTouches[0].pageX\n      } else if (event.type === 'mousemove') {\n        pageX = event.pageX\n      }\n\n      const newWidth = Math.max(\n        currentlyResizing.parentWidth + pageX - currentlyResizing.startX,\n        minResizeWidth\n      )\n\n      newResized.push({\n        id: currentlyResizing.id,\n        value: newWidth,\n      })\n\n      this.setStateWithData(\n        {\n          resized: newResized,\n        },\n        () => onResizedChange && onResizedChange(newResized, event)\n      )\n    }\n\n    resizeColumnEnd (event) {\n      event.stopPropagation()\n      const isTouch = event.type === 'touchend' || event.type === 'touchcancel'\n\n      if (isTouch) {\n        document.removeEventListener('touchmove', this.resizeColumnMoving)\n        document.removeEventListener('touchcancel', this.resizeColumnEnd)\n        document.removeEventListener('touchend', this.resizeColumnEnd)\n      }\n\n      // If its a touch event clear the mouse one's as well because sometimes\n      // the mouseDown event gets called as well, but the mouseUp event doesn't\n      document.removeEventListener('mousemove', this.resizeColumnMoving)\n      document.removeEventListener('mouseup', this.resizeColumnEnd)\n      document.removeEventListener('mouseleave', this.resizeColumnEnd)\n\n      // The touch events don't propagate up to the sorting's onMouseDown event so\n      // no need to prevent it from happening or else the first click after a touch\n      // event resize will not sort the column.\n      if (!isTouch) {\n        this.setStateWithData({\n          skipNextSort: true,\n          currentlyResizing: false,\n        })\n      }\n    }\n  }\n"]},"metadata":{},"sourceType":"module"}